#!/usr/bin/perl
# check_syncthing - Monitor you syncthing daemon
# Copyright (C) 2016 Josef 'veloc1ty' Stautner (hello@veloc1ty.de)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

use strict;
use LWP::UserAgent;
use JSON;
use Getopt::Long;

our $ARG_API_URL = '';
our $ARG_API_KEY = '';

our $LIMIT_MIN_CONNECTED_ENDPOINTS_CRIT = 0;
our $LIMIT_MIN_CONNECTED_ENDPOINTS_WARN = 1;

sub exitCritical {
    printf("CRITICAL - %s\n", shift);
    exit(2);
}

sub exitUnknown {
    printf("UNKNOWN - %s\n", shift);
    exit(3);
}

sub parseArguments {
    GetOptions(
        'syncthing-url=s' => \$ARG_API_URL,
        'api-key=s' => \$ARG_API_KEY,
        'min-connected-endpoints-warn=i' =>
            \$LIMIT_MIN_CONNECTED_ENDPOINTS_WARN,
        'min-connected-endpoints-crit=i' =>
            \$LIMIT_MIN_CONNECTED_ENDPOINTS_CRIT
    );
}

sub validateArguments {
    if ( length($ARG_API_URL) == 0 ) {
        exitUnknown('--syncthing-url not provided');
    }

    if ( $ARG_API_URL !~ /^(http|https).*$/ ) {
        exitUnknown('--syncthing-url not valid')
    }

    if ( length($ARG_API_KEY) == 0 ) {
        exitUnknown('--api-key not given');
    }

    if ( $LIMIT_MIN_CONNECTED_ENDPOINTS_WARN <
        $LIMIT_MIN_CONNECTED_ENDPOINTS_CRIT ) {
        exitUnknown('Minimum connected endpoints warn value is smaller ' .
            'than critical value');
    }
}

sub prepareUserAgent {
    my $userAgent = LWP::UserAgent->new(
        'agent' => 'check_syncthing',
        'timeout' => 10
    );

    $userAgent->ssl_opts( verify_hostname => 0 ,SSL_verify_mode => 0x00);
    $userAgent->default_header( 'X-API-Key' => $ARG_API_KEY );

    return $userAgent;
}

sub getConnectedEndpointStats {
    my $userAgent = shift;
    my $knownEndpoints = 0;
    my $connectedEndpoints = 0;

    my $response = $userAgent->get(sprintf('%s/rest/system/connections',
        $ARG_API_URL));

    if ( $response->is_success ) {
        my $content = decode_json($response->decoded_content);

        foreach my $currentConnection ( keys %{$content->{'connections'}} ) {
            $knownEndpoints++;

            # Is the device connected?
            if ( $content->{'connections'}
                ->{$currentConnection}->{'connected'} == JSON::true ) {
                    $connectedEndpoints++;
                }
        }

        # Decrement $knownEndpoints by 1 because the current syncthing
        # instance is listet as a client
        $knownEndpoints--;

        return $knownEndpoints, $connectedEndpoints;
    }
    else {
        exitCritical(sprintf('HTTP Code: %d - Failed to read API response',
            $response->status_line));
    }
}

sub main {
    parseArguments();
    validateArguments();

    my $userAgent = prepareUserAgent();
    my ($knownEndpoints,$connectedEndpoints) =
        getConnectedEndpointStats($userAgent);

    # Build performance data string
    my $performanceData = sprintf('|knownEndpoints=%d ' .
        'connectedEndpoints=%d;%d;%d',
        $knownEndpoints,
        $connectedEndpoints,
        $LIMIT_MIN_CONNECTED_ENDPOINTS_WARN,
        $LIMIT_MIN_CONNECTED_ENDPOINTS_CRIT);

    # Check limits
    if ( $connectedEndpoints < $LIMIT_MIN_CONNECTED_ENDPOINTS_CRIT ) {
        exitCritical(
            sprintf("%d of %d endpoints are connected. Minimum is %d%s",
                $connectedEndpoints,
                $knownEndpoints,
                $LIMIT_MIN_CONNECTED_ENDPOINTS_CRIT,
                $performanceData));
    }
    elsif ( $connectedEndpoints < $LIMIT_MIN_CONNECTED_ENDPOINTS_WARN ) {
        printf("WARNING - %d of %d endpoints are connected. Minimum is %d%s\n",
            $connectedEndpoints,
            $knownEndpoints,
            $LIMIT_MIN_CONNECTED_ENDPOINTS_WARN,
            $performanceData);

        exit(1);
    }
    else {
        printf("OK - %d of %d endpoints are connected%s\n",
            $connectedEndpoints,
            $knownEndpoints,
            $performanceData);
    }
}

main();
